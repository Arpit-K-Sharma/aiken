"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Bip32Account_bip32Ed25519, _Bip32Account_blake2b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bip32Account = void 0;
const types_1 = require("./types");
const crypto_1 = require("@cardano-sdk/crypto");
const core_1 = require("@cardano-sdk/core");
class Bip32Account {
    constructor({ extendedAccountPublicKey, chainId, accountIndex }, dependencies) {
        _Bip32Account_bip32Ed25519.set(this, void 0);
        _Bip32Account_blake2b.set(this, void 0);
        this.extendedAccountPublicKeyHex = extendedAccountPublicKey;
        __classPrivateFieldSet(this, _Bip32Account_bip32Ed25519, dependencies.bip32Ed25519, "f");
        __classPrivateFieldSet(this, _Bip32Account_blake2b, dependencies.blake2b, "f");
        this.chainId = chainId;
        this.accountIndex = accountIndex;
    }
    async derivePublicKey(derivationPath) {
        const extendedKey = await __classPrivateFieldGet(this, _Bip32Account_bip32Ed25519, "f").derivePublicKeyAsync(this.extendedAccountPublicKeyHex, [
            derivationPath.role,
            derivationPath.index
        ]);
        return crypto_1.Ed25519PublicKeyHex.fromBip32PublicKey(extendedKey);
    }
    async deriveAddress(paymentKeyDerivationPath, stakeKeyDerivationIndex) {
        const stakeKeyDerivationPath = {
            index: stakeKeyDerivationIndex,
            role: types_1.KeyRole.Stake
        };
        const derivedPublicPaymentKey = await this.derivePublicKey({
            index: paymentKeyDerivationPath.index,
            role: Number(paymentKeyDerivationPath.type)
        });
        const derivedPublicPaymentKeyHash = (await __classPrivateFieldGet(this, _Bip32Account_blake2b, "f").hashAsync(derivedPublicPaymentKey, crypto_1.BIP32_PUBLIC_KEY_HASH_LENGTH));
        const publicStakeKey = await this.derivePublicKey(stakeKeyDerivationPath);
        const publicStakeKeyHash = (await __classPrivateFieldGet(this, _Bip32Account_blake2b, "f").hashAsync(publicStakeKey, crypto_1.BIP32_PUBLIC_KEY_HASH_LENGTH));
        const stakeCredential = { hash: publicStakeKeyHash, type: core_1.Cardano.CredentialType.KeyHash };
        const address = core_1.Cardano.BaseAddress.fromCredentials(this.chainId.networkId, { hash: derivedPublicPaymentKeyHash, type: core_1.Cardano.CredentialType.KeyHash }, stakeCredential).toAddress();
        const rewardAccount = core_1.Cardano.RewardAddress.fromCredentials(this.chainId.networkId, stakeCredential).toAddress();
        return {
            accountIndex: this.accountIndex,
            address: core_1.Cardano.PaymentAddress(address.toBech32()),
            networkId: this.chainId.networkId,
            rewardAccount: core_1.Cardano.RewardAccount(rewardAccount.toBech32()),
            stakeKeyDerivationPath,
            ...paymentKeyDerivationPath
        };
    }
    static async createDefaultDependencies() {
        return {
            bip32Ed25519: await crypto_1.SodiumBip32Ed25519.create(),
            blake2b: crypto_1.blake2b
        };
    }
    static async fromAsyncKeyAgent(keyAgent, dependencies) {
        dependencies ||= await Bip32Account.createDefaultDependencies();
        return new Bip32Account({
            accountIndex: await keyAgent.getAccountIndex(),
            chainId: await keyAgent.getChainId(),
            extendedAccountPublicKey: await keyAgent.getExtendedAccountPublicKey()
        }, dependencies);
    }
}
exports.Bip32Account = Bip32Account;
_Bip32Account_bip32Ed25519 = new WeakMap(), _Bip32Account_blake2b = new WeakMap();
//# sourceMappingURL=Bip32Account.js.map