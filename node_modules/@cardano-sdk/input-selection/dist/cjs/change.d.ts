import { Cardano } from '@cardano-sdk/core';
import { ComputeMinimumCoinQuantity, TokenBundleSizeExceedsLimit, TxCosts } from './types';
import { RequiredImplicitValue, UtxoSelection } from './util';
declare type EstimateTxCostsWithOriginalOutputs = (utxo: Cardano.Utxo[], change: Cardano.Value[]) => Promise<TxCosts>;
export declare type PickAdditionalUtxo = (selection: UtxoSelection) => UtxoSelection;
interface ChangeComputationArgs {
    utxoSelection: UtxoSelection;
    outputValues: Cardano.Value[];
    uniqueTxAssetIDs: Cardano.AssetId[];
    implicitValue: RequiredImplicitValue;
    estimateTxCosts: EstimateTxCostsWithOriginalOutputs;
    computeMinimumCoinQuantity: ComputeMinimumCoinQuantity;
    tokenBundleSizeExceedsLimit: TokenBundleSizeExceedsLimit;
    pickAdditionalUtxo: PickAdditionalUtxo;
}
interface ChangeComputationResult {
    remainingUTxO: Cardano.Utxo[];
    inputs: Cardano.Utxo[];
    change: Cardano.Value[];
    fee: Cardano.Lovelace;
    redeemers?: Array<Cardano.Redeemer>;
}
export declare const coalesceChangeBundlesForMinCoinRequirement: (changeBundles: Cardano.Value[], computeMinimumCoinQuantity: ComputeMinimumCoinQuantity) => Cardano.Value[] | undefined;
export declare const computeChangeAndAdjustForFee: ({ computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, estimateTxCosts, outputValues, uniqueTxAssetIDs, implicitValue, pickAdditionalUtxo, utxoSelection }: ChangeComputationArgs) => Promise<ChangeComputationResult>;
export {};
//# sourceMappingURL=change.d.ts.map