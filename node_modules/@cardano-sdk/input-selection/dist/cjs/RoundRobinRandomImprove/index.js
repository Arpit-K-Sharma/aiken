"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundRobinRandomImprove = exports.createPickAdditionalRandomUtxo = void 0;
const InputSelectionError_1 = require("../InputSelectionError");
const util_1 = require("../util");
const change_1 = require("../change");
const roundRobin_1 = require("./roundRobin");
const createPickAdditionalRandomUtxo = (random) => ({ utxoRemaining, utxoSelected }) => {
    const remainingUtxoOfOnlyCoin = utxoRemaining.filter(([_, { value }]) => !value.assets);
    const pickFrom = remainingUtxoOfOnlyCoin.length > 0 ? remainingUtxoOfOnlyCoin : utxoRemaining;
    const pickIdx = Math.floor(random() * pickFrom.length);
    const newUtxoSelected = [...utxoSelected, pickFrom[pickIdx]];
    const originalIdx = utxoRemaining.indexOf(pickFrom[pickIdx]);
    const newUtxoRemaining = [...utxoRemaining.slice(0, originalIdx), ...utxoRemaining.slice(originalIdx + 1)];
    return { utxoRemaining: newUtxoRemaining, utxoSelected: newUtxoSelected };
};
exports.createPickAdditionalRandomUtxo = createPickAdditionalRandomUtxo;
const roundRobinRandomImprove = ({ changeAddressResolver, random = Math.random }) => ({
    select: async ({ preSelectedUtxo: preSelectedUtxoSet, utxo: utxoSet, outputs: outputSet, constraints: { computeMinimumCost, computeSelectionLimit, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit }, implicitValue: partialImplicitValue = {} }) => {
        const changeAddress = util_1.stubMaxSizeAddress;
        const { requiredUtxo, utxo, outputs, uniqueTxAssetIDs, implicitValue } = (0, util_1.preProcessArgs)(preSelectedUtxoSet, utxoSet, outputSet, changeAddress, partialImplicitValue);
        (0, util_1.assertIsBalanceSufficient)(uniqueTxAssetIDs, requiredUtxo, utxo, outputs, implicitValue);
        const roundRobinSelectionResult = (0, roundRobin_1.roundRobinSelection)({
            changeAddress,
            implicitValue,
            outputs,
            random,
            requiredUtxo,
            uniqueTxAssetIDs,
            utxo
        });
        const result = await (0, change_1.computeChangeAndAdjustForFee)({
            computeMinimumCoinQuantity,
            estimateTxCosts: (utxos, changeValues) => computeMinimumCost({
                change: changeValues.map((value) => ({
                    address: changeAddress,
                    value
                })),
                fee: util_1.MAX_U64,
                inputs: new Set(utxos),
                outputs: outputSet
            }),
            implicitValue,
            outputValues: (0, util_1.toValues)(outputs),
            pickAdditionalUtxo: (0, exports.createPickAdditionalRandomUtxo)(random),
            tokenBundleSizeExceedsLimit,
            uniqueTxAssetIDs,
            utxoSelection: roundRobinSelectionResult
        });
        const inputs = new Set(result.inputs);
        const selection = {
            change: result.change.map((value) => ({
                address: changeAddress,
                value
            })),
            fee: result.fee,
            inputs,
            outputs: outputSet
        };
        selection.change = await changeAddressResolver.resolve(selection);
        if (result.inputs.length >
            (await computeSelectionLimit({ change: selection.change, fee: selection.fee, inputs, outputs: outputSet }))) {
            throw new InputSelectionError_1.InputSelectionError(InputSelectionError_1.InputSelectionFailure.MaximumInputCountExceeded);
        }
        selection.inputs = new Set([...selection.inputs].sort(util_1.sortUtxoByTxIn));
        return {
            redeemers: result.redeemers,
            remainingUTxO: new Set(result.remainingUTxO),
            selection
        };
    }
});
exports.roundRobinRandomImprove = roundRobinRandomImprove;
//# sourceMappingURL=index.js.map