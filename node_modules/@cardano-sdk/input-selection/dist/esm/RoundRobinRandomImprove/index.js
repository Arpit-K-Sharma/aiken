import { InputSelectionError, InputSelectionFailure } from '../InputSelectionError.js';
import { MAX_U64, assertIsBalanceSufficient, preProcessArgs, sortUtxoByTxIn, stubMaxSizeAddress, toValues } from '../util.js';
import { computeChangeAndAdjustForFee } from '../change.js';
import { roundRobinSelection } from './roundRobin.js';
export const createPickAdditionalRandomUtxo = (random) => ({ utxoRemaining, utxoSelected }) => {
    const remainingUtxoOfOnlyCoin = utxoRemaining.filter(([_, { value }]) => !value.assets);
    const pickFrom = remainingUtxoOfOnlyCoin.length > 0 ? remainingUtxoOfOnlyCoin : utxoRemaining;
    const pickIdx = Math.floor(random() * pickFrom.length);
    const newUtxoSelected = [...utxoSelected, pickFrom[pickIdx]];
    const originalIdx = utxoRemaining.indexOf(pickFrom[pickIdx]);
    const newUtxoRemaining = [...utxoRemaining.slice(0, originalIdx), ...utxoRemaining.slice(originalIdx + 1)];
    return { utxoRemaining: newUtxoRemaining, utxoSelected: newUtxoSelected };
};
export const roundRobinRandomImprove = ({ changeAddressResolver, random = Math.random }) => ({
    select: async ({ preSelectedUtxo: preSelectedUtxoSet, utxo: utxoSet, outputs: outputSet, constraints: { computeMinimumCost, computeSelectionLimit, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit }, implicitValue: partialImplicitValue = {} }) => {
        const changeAddress = stubMaxSizeAddress;
        const { requiredUtxo, utxo, outputs, uniqueTxAssetIDs, implicitValue } = preProcessArgs(preSelectedUtxoSet, utxoSet, outputSet, changeAddress, partialImplicitValue);
        assertIsBalanceSufficient(uniqueTxAssetIDs, requiredUtxo, utxo, outputs, implicitValue);
        const roundRobinSelectionResult = roundRobinSelection({
            changeAddress,
            implicitValue,
            outputs,
            random,
            requiredUtxo,
            uniqueTxAssetIDs,
            utxo
        });
        const result = await computeChangeAndAdjustForFee({
            computeMinimumCoinQuantity,
            estimateTxCosts: (utxos, changeValues) => computeMinimumCost({
                change: changeValues.map((value) => ({
                    address: changeAddress,
                    value
                })),
                fee: MAX_U64,
                inputs: new Set(utxos),
                outputs: outputSet
            }),
            implicitValue,
            outputValues: toValues(outputs),
            pickAdditionalUtxo: createPickAdditionalRandomUtxo(random),
            tokenBundleSizeExceedsLimit,
            uniqueTxAssetIDs,
            utxoSelection: roundRobinSelectionResult
        });
        const inputs = new Set(result.inputs);
        const selection = {
            change: result.change.map((value) => ({
                address: changeAddress,
                value
            })),
            fee: result.fee,
            inputs,
            outputs: outputSet
        };
        selection.change = await changeAddressResolver.resolve(selection);
        if (result.inputs.length >
            (await computeSelectionLimit({ change: selection.change, fee: selection.fee, inputs, outputs: outputSet }))) {
            throw new InputSelectionError(InputSelectionFailure.MaximumInputCountExceeded);
        }
        selection.inputs = new Set([...selection.inputs].sort(sortUtxoByTxIn));
        return {
            redeemers: result.redeemers,
            remainingUTxO: new Set(result.remainingUTxO),
            selection
        };
    }
});
//# sourceMappingURL=index.js.map