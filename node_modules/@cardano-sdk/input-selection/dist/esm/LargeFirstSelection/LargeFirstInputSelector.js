var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LargeFirstSelector_instances, _LargeFirstSelector_props, _LargeFirstSelector_aggregateLovelace, _LargeFirstSelector_aggregateAssets, _LargeFirstSelector_computeNetImplicitSelectionValues, _LargeFirstSelector_selectAssets, _LargeFirstSelector_selectLovelace, _LargeFirstSelector_computeRemainingUtxo, _LargeFirstSelector_expandUtxosUntilFeeCovered;
import { coalesceValueQuantities } from '@cardano-sdk/core';
import { MAX_U64, addTokenMaps, getCoinQuantity, hasNegativeAssetValue, mintToImplicitTokens, sortByAssetQuantity, sortByCoins, sortUtxoByTxIn, stubMaxSizeAddress, subtractTokenMaps, toValues } from '../util.js';
import { InputSelectionError, InputSelectionFailure } from '../InputSelectionError.js';
import { computeChangeAndAdjustForFee } from '../change.js';
import uniq from 'lodash/uniq.js';
const pickAdditionalLargestUtxo = ({ utxoRemaining, utxoSelected }) => {
    if (utxoRemaining.length === 0) {
        return { utxoRemaining, utxoSelected };
    }
    const sorted = utxoRemaining.sort(([, a], [, b]) => sortByCoins(a, b));
    const [picked, ...newRemaining] = sorted;
    return {
        utxoRemaining: newRemaining,
        utxoSelected: [...utxoSelected, picked]
    };
};
export class LargeFirstSelector {
    constructor(props) {
        _LargeFirstSelector_instances.add(this);
        _LargeFirstSelector_props.set(this, void 0);
        __classPrivateFieldSet(this, _LargeFirstSelector_props, props, "f");
    }
    async select(params) {
        const { utxo, preSelectedUtxo, outputs, constraints, implicitValue } = params;
        const preSelected = [...preSelectedUtxo];
        const available = [...utxo].filter(([txIn]) => !preSelected.some(([preTxIn]) => preTxIn.txId === txIn.txId && preTxIn.index === txIn.index));
        const allAvailable = [...preSelected, ...available];
        const { totalLovelaceOutput, outputAssets } = __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_computeNetImplicitSelectionValues).call(this, new Set(allAvailable), outputs, implicitValue);
        let workingUtxo = new Set(preSelected);
        workingUtxo = __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_selectAssets).call(this, outputAssets, allAvailable, [...workingUtxo]);
        workingUtxo = __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_selectLovelace).call(this, totalLovelaceOutput, allAvailable, workingUtxo, implicitValue?.coin?.input ?? 0n);
        const { finalSelection, fee, change } = await __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_expandUtxosUntilFeeCovered).call(this, workingUtxo, outputs, allAvailable, outputAssets, constraints, __classPrivateFieldGet(this, _LargeFirstSelector_props, "f").changeAddressResolver, implicitValue);
        const limit = await constraints.computeSelectionLimit({ change, fee, inputs: finalSelection, outputs });
        if (finalSelection.size > limit)
            throw new InputSelectionError(InputSelectionFailure.MaximumInputCountExceeded);
        return {
            remainingUTxO: __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_computeRemainingUtxo).call(this, [...utxo], finalSelection),
            selection: {
                change,
                fee,
                inputs: new Set([...finalSelection].sort(sortUtxoByTxIn)),
                outputs
            }
        };
    }
}
_LargeFirstSelector_props = new WeakMap(), _LargeFirstSelector_instances = new WeakSet(), _LargeFirstSelector_aggregateLovelace = function _LargeFirstSelector_aggregateLovelace(inputs, outputs, implicit) {
    const utxoAda = getCoinQuantity(inputs);
    const outputAda = getCoinQuantity(outputs);
    const withdrawAda = implicit?.coin?.input ?? 0n;
    const depositAda = implicit?.coin?.deposit ?? 0n;
    return {
        totalIn: utxoAda + withdrawAda,
        totalOut: outputAda + depositAda
    };
}, _LargeFirstSelector_aggregateAssets = function _LargeFirstSelector_aggregateAssets(inputs, outputs, implicit) {
    const outputsMap = coalesceValueQuantities(outputs).assets ?? new Map();
    const utxoMap = coalesceValueQuantities(inputs).assets;
    const mint = implicit?.mint ?? new Map();
    const posMint = new Map();
    const negMint = new Map();
    for (const [id, q] of mint)
        (q > 0n ? posMint : negMint).set(id, q > 0n ? q : -q);
    let required = addTokenMaps(outputsMap, negMint);
    required = subtractTokenMaps(required, posMint) ?? new Map();
    const available = addTokenMaps(utxoMap, posMint) ?? new Map();
    return { available, required };
}, _LargeFirstSelector_computeNetImplicitSelectionValues = function _LargeFirstSelector_computeNetImplicitSelectionValues(inputs, outputs, implicitValue) {
    const inputVals = toValues([...inputs]);
    const outputVals = toValues([...outputs]);
    const { totalIn, totalOut } = __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_aggregateLovelace).call(this, inputVals, outputVals, implicitValue);
    const { required, available } = __classPrivateFieldGet(this, _LargeFirstSelector_instances, "m", _LargeFirstSelector_aggregateAssets).call(this, inputVals, outputVals, implicitValue);
    const changeAda = totalIn - totalOut;
    const changeAssets = subtractTokenMaps(available, required);
    if (inputs.size === 0 || changeAda < 0n || hasNegativeAssetValue(changeAssets))
        throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    return {
        outputAssets: required,
        totalLovelaceInput: totalIn,
        totalLovelaceOutput: totalOut
    };
}, _LargeFirstSelector_selectAssets = function _LargeFirstSelector_selectAssets(requiredAssets, allAvailable, preSelected) {
    const selected = new Set(preSelected);
    for (const [assetId, requiredQuantity] of requiredAssets) {
        const candidates = allAvailable
            .filter(([_, out]) => (out.value.assets?.get(assetId) ?? 0n) > 0n)
            .sort(([, a], [, b]) => sortByAssetQuantity(assetId)(a, b));
        let accumulated = 0n;
        for (const candidate of candidates) {
            selected.add(candidate);
            accumulated += candidate[1].value.assets?.get(assetId) ?? 0n;
            if (accumulated >= requiredQuantity)
                break;
        }
        if (accumulated < requiredQuantity)
            throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    }
    return selected;
}, _LargeFirstSelector_selectLovelace = function _LargeFirstSelector_selectLovelace(target, allAvailable, selected, implicitCoinInput) {
    const result = new Set(selected);
    const selectedTxIns = new Set([...selected].map(([txIn]) => txIn));
    const adaCandidates = allAvailable
        .filter(([txIn]) => !selectedTxIns.has(txIn))
        .sort(([, a], [, b]) => sortByCoins(a, b));
    let adaAccumulated = getCoinQuantity(toValues([...result])) + implicitCoinInput;
    for (const candidate of adaCandidates) {
        if (adaAccumulated >= target)
            break;
        result.add(candidate);
        adaAccumulated += candidate[1].value.coins;
    }
    if (result.size === 0) {
        if (adaCandidates.length === 0)
            throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
        result.add(adaCandidates[0]);
    }
    if (adaAccumulated < target)
        throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    return result;
}, _LargeFirstSelector_computeRemainingUtxo = function _LargeFirstSelector_computeRemainingUtxo(original, used) {
    const usedTxIns = new Set([...used].map(([txIn]) => txIn));
    return new Set(original.filter(([txIn]) => !usedTxIns.has(txIn)));
}, _LargeFirstSelector_expandUtxosUntilFeeCovered = async function _LargeFirstSelector_expandUtxosUntilFeeCovered(initialInputs, outputs, allAvailable, requiredAssets, constraints, changeAddressResolver, implicitValue) {
    const utxoSelectedArr = [...initialInputs];
    const utxoRemainingArr = allAvailable
        .filter((u) => !initialInputs.has(u))
        .sort(([, a], [, b]) => sortByCoins(a, b));
    const outputValues = toValues([...outputs]);
    const changeAddress = stubMaxSizeAddress;
    const implicitCoin = {
        deposit: implicitValue?.coin?.deposit || 0n,
        input: implicitValue?.coin?.input || 0n,
        reclaimDeposit: implicitValue?.coin?.reclaimDeposit || 0n,
        withdrawals: implicitValue?.coin?.withdrawals || 0n
    };
    const mintMap = implicitValue?.mint || new Map();
    const uniqueTxAssetIDs = uniq([...requiredAssets.keys(), ...mintMap.keys()]);
    const { implicitTokensInput, implicitTokensSpend } = mintToImplicitTokens(mintMap);
    const implicitTokens = {
        input: (assetId) => implicitTokensInput.get(assetId) || 0n,
        spend: (assetId) => implicitTokensSpend.get(assetId) || 0n
    };
    const { change, fee, inputs: finalInputs } = await computeChangeAndAdjustForFee({
        computeMinimumCoinQuantity: constraints.computeMinimumCoinQuantity,
        estimateTxCosts: (utxos, changeValues) => constraints.computeMinimumCost({
            change: changeValues.map((value) => ({
                address: changeAddress,
                value
            })),
            fee: MAX_U64,
            inputs: new Set(utxos),
            outputs
        }),
        implicitValue: {
            implicitCoin,
            implicitTokens
        },
        outputValues,
        pickAdditionalUtxo: pickAdditionalLargestUtxo,
        tokenBundleSizeExceedsLimit: constraints.tokenBundleSizeExceedsLimit,
        uniqueTxAssetIDs,
        utxoSelection: {
            utxoRemaining: utxoRemainingArr,
            utxoSelected: utxoSelectedArr
        }
    });
    if (change.length === 0) {
        return {
            change: [],
            fee,
            finalSelection: new Set(finalInputs)
        };
    }
    const changeTxOuts = change.map((val) => ({
        address: changeAddress,
        value: val
    }));
    const resolvedChange = await changeAddressResolver.resolve({
        change: changeTxOuts,
        fee,
        inputs: new Set(finalInputs),
        outputs
    });
    return {
        change: resolvedChange,
        fee,
        finalSelection: new Set(finalInputs)
    };
};
//# sourceMappingURL=LargeFirstInputSelector.js.map